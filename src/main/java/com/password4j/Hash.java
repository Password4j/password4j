/*
 *  (C) Copyright 2020 Password4j (http://password4j.com/).
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package com.password4j;

import java.util.Arrays;
import java.util.Objects;


/**
 * This class contains all the information computed after
 * calculating a cryptographic hash.
 * <p>
 * The same {@link HashingFunction} used to generate the hash
 * is used to verify the plain password; in addition <i>cryptographic
 * seasoning</i> such as salt and pepper are stored in this object.
 * <p>
 * A hash is the product of a one-way function that maps data of arbitrary size to
 * fixed-size values; it is called hashing function (HF).
 * This class represent hashes generated by cryptographic hash function (CHF),
 * where each function has the following properties:
 * <ul>
 * <li>it is deterministic, meaning that the same message always results in the same hash</li>
 * <li>it is quick to compute the hash value for any given message</li>
 * <li>it is infeasible to generate a message that yields a given hash value</li>
 * <li>it is infeasible to find two different messages with the same hash value</li>
 * <li>a small change to a message should change the hash value so extensively that the new hash value
 * appears uncorrelated with the old hash value</li>
 * </ul>
 * <p>
 * A salt is a unique, randomly generated string that is added to each password as part of the hashing process.
 * As the salt is unique for every user, an attacker has to crack hashes one at a time using the respective salt,
 * rather than being able to calculate a hash once and compare it against every stored hash.
 * <p>
 * A pepper can be used in additional to salting to provide an additional layer of protection.
 * It is similar to a salt, but has two key differences:
 * <ul>
 * <li>The pepper is shared between all stored passwords, rather than being unique like a salt.</li>
 * <li>The pepper is not stored in the database, unlike the salts.</li>
 * </ul>
 *
 * @author David Bertoldi
 * @see <a href="https://owasp.org/www-project-cheat-sheets/cheatsheets/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a>
 * @see <a href="https://en.wikipedia.org/wiki/Key_derivation_function">Key derivation function</a>
 * @see <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Cryptographic hash function</a>
 * @since 0.1.0
 */
public class Hash
{

    /**
     * Represents the full output of a cryptographic hashing function.
     * Depending on the implementation of the CHF, it may contain
     * the salt and the configuration of the CHF itself.
     */
    private byte[] result;

    /**
     * Represents the computed output of a cryptographic hashing function.
     * It never contains salt and other configurations.
     */
    private byte[] bytes;

    /**
     * Represents the salt: random data that is used as an additional input
     * to a cryptographic hashing function.
     */
    private byte[] salt;

    /**
     * Represents the pepper: a secret added to the input password
     * prior to being hashed with a cryptographic hash function
     */
    private CharSequence pepper;

    /**
     * Represents the hashing function used to generate this object.
     *
     * @see HashingFunction for more details
     */
    private HashingFunction hashingFunction;

    /**
     * It is meant to not be used if not internally.
     * The other constructor must be used instead.
     *
     * @see Hash#Hash(HashingFunction, String, byte[], String)
     * @since 0.1.0
     */
    @SuppressWarnings("unused")
    private Hash()
    {
        //
    }

    /**
     * Constructs an {@link Hash} containing the basic information
     * used and produced by the computational process of hashing a password.
     * Other information, like <i>pepper</i> can be added with
     * {@link #setPepper(CharSequence)}.
     * <p>
     * This constructor populates the object's attributes.
     *
     * @param hashingFunction the cryptographic algorithm used to produce the hash.
     * @param result          the result of the computation of the hash.
     *                        Notice that the format varies depending on the algorithm.
     * @param bytes           the hash without additional information.
     * @param salt            the salt used for the computation.
     * @since 0.1.0
     * @deprecated As of 1.8.1 because of the salt conversion from {@link String} to byte[].
     * {@link Hash#Hash(HashingFunction, String, byte[], byte[])} should be used instead.
     */
    @Deprecated
    public Hash(HashingFunction hashingFunction, String result, byte[] bytes, String salt)
    {
        this(hashingFunction, Utils.fromCharSequenceToBytes(result), bytes, Utils.fromCharSequenceToBytes(salt));
    }


    /**
     * Constructs an {@link Hash} containing the basic information
     * used and produced by the computational process of hashing a password.
     * Other information, like <i>pepper</i> can be added with
     * {@link #setPepper(CharSequence)}.
     * <p>
     * This constructor populates the object's attributes.
     *
     * @param hashingFunction the cryptographic algorithm used to produce the hash.
     * @param result          the result of the computation of the hash.
     *                        Notice that the format varies depending on the algorithm.
     * @param bytes           the hash without additional information.
     * @param salt            the salt used for the computation.
     * @since 0.1.0
     */
    public Hash(HashingFunction hashingFunction, String result, byte[] bytes, byte[] salt)
    {
        this(hashingFunction, Utils.fromCharSequenceToBytes(result), bytes, salt);
    }

    /**
     * Constructs an {@link Hash} containing the basic information
     * used and produced by the computational process of hashing a password.
     * Other information, like <i>pepper</i> can be added with
     * {@link #setPepper(CharSequence)}.
     * <p>
     * This constructor populates the object's attributes.
     *
     * @param hashingFunction the cryptographic algorithm used to produce the hash.
     * @param result          the result of the computation of the hash as bytes array.
     *                        Notice that the format varies depending on the algorithm.
     * @param bytes           the hash without additional information.
     * @param salt            the salt used for the computation as bytes array.
     * @since 1.7.0
     */
    public Hash(HashingFunction hashingFunction, byte[] result, byte[] bytes, byte[] salt)
    {
        this.hashingFunction = hashingFunction;
        this.salt = salt;
        this.result = result;
        this.bytes = bytes;
    }

    private static boolean areEquals(CharSequence cs1, CharSequence cs2)
    {
        if (cs1 == cs2)
        {
            return true;
        }
        else if (cs1 != null && cs2 != null)
        {
            return cs1.equals(cs2);
        }
        return false;
    }

    /**
     * Retrieves the hash computed by the hashing function.
     *
     * @return the hash.
     * @since 0.1.0
     */
    public String getResult()
    {
        return Utils.fromBytesToString(result);
    }

    /**
     * Retrieves the hash computed by the hashing function.
     *
     * @return the hash.
     * @since 0.1.0
     */
    public byte[] getResultAsBytes()
    {
        return result;
    }

    /**
     * Retrieves the hash as byte array and without the parameters
     * encoded in the final hash.
     *
     * @return the hash.
     * @since 1.5.1
     */
    public byte[] getBytes()
    {
        return bytes;
    }

    /**
     * Retrieves the {@link HashingFunction} used
     * to hash the password.
     *
     * @return the CHF
     * @since 0.4.0
     */
    public HashingFunction getHashingFunction()
    {
        return hashingFunction;
    }

    /**
     * Retrieves the salt used by the hashing function.
     *
     * @return the salt as {@link String}.
     * @since 0.1.0
     */
    public String getSalt()
    {
        return Utils.fromBytesToString(salt);
    }

    /**
     * Retrieves the salt used by the hashing function.
     *
     * @return the salt as bytes array.
     * @since 1.7.0
     */
    public byte[] getSaltBytes()
    {
        return salt;
    }

    /**
     * Retrieves the pepper used with the password in the hashing function.
     *
     * @return the pepper.
     * @since 0.1.0
     */
    public CharSequence getPepper()
    {
        return pepper;
    }

    /**
     * Stores the pepper used together with the password in the hashing function.
     * <p>
     * This methods should be used just after the creation of this object.
     *
     * @param pepper the pepper used.
     * @since 0.1.0
     */
    void setPepper(CharSequence pepper)
    {
        this.pepper = pepper;
    }

    /**
     * Produces a human-readable description of the {@link Hash}.
     *
     * @return a readable version of this object
     * @since 0.1.0
     */
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();
        if (this.hashingFunction != null)
        {
            sb.append(hashingFunction.getClass().getSimpleName());
        }
        sb.append("[salt=").append(getSalt()).append(", pepper=").append(getPepper()).append(", hash=").append(getResult())
                .append("]");
        return sb.toString();
    }

    /**
     * Two {@link Hash}es are considered equals if they contain
     * the same hash, salt, pepper and they are generated with
     * the same {@link HashingFunction}
     *
     * @param obj the object to compare
     * @return true if equals
     * @since 0.1.0
     */
    @Override
    public boolean equals(Object obj)
    {
        if (obj == null || !this.getClass().equals(obj.getClass()))
        {
            return false;
        }

        Hash otherHash = (Hash) obj;
        return hasSameValues(otherHash);
    }

    private boolean hasSameValues(Hash otherHash)
    {
        return Arrays.equals(this.result, otherHash.result) //
                && Arrays.equals(this.bytes, otherHash.bytes) //
                && Arrays.equals(this.salt, otherHash.salt) //
                && areEquals(this.pepper, otherHash.pepper) //
                && this.hashingFunction.equals(otherHash.hashingFunction);
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(Arrays.hashCode(result), Arrays.hashCode(salt), pepper, hashingFunction);
    }
}
