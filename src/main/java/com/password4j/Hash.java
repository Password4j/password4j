/*
 *  (C) Copyright 2020 Password4j (http://password4j.com/).
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package com.password4j;

import org.apache.commons.lang3.StringUtils;

import java.util.Objects;


/**
 * This class contains all the information computed after
 * calculating a cryptographic hash.
 * <p>
 * The same {@link HashingFunction} used to generate the hash
 * is used to verify the plain password; in addition <i>cryptographic
 * seasoning</i> such as salt and pepper are stored in this object.
 * <p>
 * An hash is the product of a one-way function that maps data of arbitrary size to
 * fixed-size values; it is called hashing function (HF).
 * This class represent hashes generated by cryptographic hash function (CHF),
 * where each function has the following properties:
 * <ul>
 * <li>it is deterministic, meaning that the same message always results in the same hash</li>
 * <li>it is quick to compute the hash value for any given message</li>
 * <li>it is infeasible to generate a message that yields a given hash value</li>
 * <li>it is infeasible to find two different messages with the same hash value</li>
 * <li>a small change to a message should change the hash value so extensively that the new hash value
 * appears uncorrelated with the old hash value</li>
 * </ul>
 * <p>
 * A salt is a unique, randomly generated string that is added to each password as part of the hashing process.
 * As the salt is unique for every user, an attacker has to crack hashes one at a time using the respective salt,
 * rather than being able to calculate a hash once and compare it against every stored hash.
 * <p>
 * A pepper can be used in additional to salting to provide an additional layer of protection.
 * It is similar to a salt, but has two key differences:
 * <ul>
 * <li>The pepper is shared between all stored passwords, rather than being unique like a salt.</li>
 * <li>The pepper is not stored in the database, unlike the salts.</li>
 * </ul>
 *
 * @author David Bertoldi
 * @see <a href="https://owasp.org/www-project-cheat-sheets/cheatsheets/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a>
 * @see <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Cryptographic hash function</a>
 * @since 0.1.0
 */
public class Hash
{
    /**
     * Represents the full output of a cryptographic hashing function.
     * Depending on the implementation of the CHF, it may contain
     * the salt and the configuration of the CHF itself.
     */
    private String result;

    /**
     * Represents the salt: random data that is used as an additional input
     * to a cryptographic hashing function.
     */
    private String salt;

    /**
     * Represents the pepper: a secret added to the input password
     * prior to being hashed with a cryptographic hash function
     */
    private String pepper;

    /**
     * Represents the hashing function used to generate this object.
     *
     * @see HashingFunction for more details
     */
    private HashingFunction hashingFunction;

    /**
     * It is meant to not be used if not internally.
     * The other constructor must be used instead.
     *
     * @see Hash#Hash(HashingFunction, String, String)
     * @since 0.1.0
     */
    @SuppressWarnings("unused")
    private Hash()
    {
        //
    }

    /**
     * Constructs an {@link Hash} containing the basic information
     * used and produced by the computational process of hashing a password.
     * Other information, like <i>pepper</i> can be added with
     * {@link #setPepper(String)}.
     * <p>
     * This constructor populates the object's attributes.
     *
     * @param hashingFunction the cryptographic algorithm used to produce the hash.
     * @param result          the result of the computation of the hash.
     *                        Notice that the format varies depending on the algorithm.
     * @param salt            the salt used for the computation.
     * @since 0.1.0
     */
    public Hash(HashingFunction hashingFunction, String result, String salt)
    {
        this.hashingFunction = hashingFunction;
        this.salt = salt;
        this.result = result;
    }

    /**
     * Retrieves the hash computed by the hashing function.
     *
     * @return the hash.
     * @since 0.1.0
     */
    public String getResult()
    {
        return result;
    }

    /**
     * Retrieves the {@link HashingFunction} used
     * to hash the password.
     *
     * @return the CHF
     * @since 0.4.0
     */
    public HashingFunction getHashingFunction()
    {
        return hashingFunction;
    }

    /**
     * Retrieves the salt used by the hashing function.
     *
     * @return the salt.
     * @since 0.1.0
     */
    public String getSalt()
    {
        return salt;
    }

    /**
     * Retrieves the pepper used with the password in the hashing function.
     *
     * @return the pepper.
     * @since 0.1.0
     */
    public String getPepper()
    {
        return pepper;
    }

    /**
     * Stores the pepper used together with the password in the hashing function.
     * <p>
     * This methods should be used just after the creation of this object.
     *
     * @param pepper the pepper used.
     * @since 0.1.0
     */
    void setPepper(String pepper)
    {
        this.pepper = pepper;
    }

    /**
     * Uses the {@link HashingFunction} used to calculate this {@link Hash}.
     * Il the password is null, this returns false; otherwise {@link HashingFunction#check(String, String)} is invoked.
     *
     * @param plain the original password.
     * @return true if the check passes, false otherwise.
     * @since 0.1.0
     */
    public boolean check(String plain)
    {
        if (plain == null)
        {
            return false;
        }

        String peppered = plain;
        if (StringUtils.isNotEmpty(this.pepper))
        {
            peppered = this.pepper + peppered;
        }

        return this.hashingFunction.check(peppered, this.getResult(), salt);
    }

    /**
     * Produces a human readable description of the {@link Hash}.
     *
     * @return a readable version of this object
     * @since 0.1.0
     */
    @Override
    public String toString()
    {
        return hashingFunction.getClass()
                .getSimpleName() + "[salt=" + getSalt() + ", pepper=" + getPepper() + ", hash=" + getResult() + "]";
    }

    /**
     * Two {@link Hash}es are considered equals if they contain
     * the same hash, salt, pepper and they are generated with
     * the same {@link HashingFunction}
     *
     * @param obj the object to compare
     * @return true if equals
     * @since 0.1.0
     */
    @Override
    public boolean equals(Object obj)
    {
        if (obj == null || !this.getClass().equals(obj.getClass()))
        {
            return false;
        }

        Hash otherHash = (Hash) obj;
        return hasSameValues(otherHash);
    }

    private boolean hasSameValues(Hash otherHash)
    {
        return StringUtils.equals(this.result, otherHash.result) //
                && StringUtils.equals(this.salt, otherHash.salt) //
                && StringUtils.equals(this.pepper, otherHash.pepper) //
                && this.hashingFunction.equals(otherHash.hashingFunction);
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(result, salt, pepper, hashingFunction);
    }
}
